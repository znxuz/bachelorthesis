\section{Hintergrund}

Die vorliegende Bachelorarbeit hat zum Ziel, die Robotersteuerungssoftware, die
derzeit auf Micro-ROS basiert, auf FreeRTOS zu portieren, um einen
vergleichenden Leistungsanalyse zwischen beiden Plattformen durchzuführen. Beide
Systeme sind für die Steuerung eines mobilen Roboters auf einem Cortex-M7
Mikrocontroller von Arm konzipiert, unterscheiden sich jedoch in ihrer
grundlegenden Architektur, was sich auch in ihrer Echtzeitfähigkeit und
Ressourcennutzung widerspiegelt. Während Micro-ROS auf der \ac{ROS 2} aufbaut
und eine höhere Abstraktionsebene sowie standardisierte
Kommunikationsschnittstellen mittels der \ac{DDS}-Middleware bietet, basiert
Micro-ROS selbst auf FreeRTOS. Die Portierung der Robotersteuerungssoftware von
Micro-ROS auf FreeRTOS kann daher als eine Reduzierung der Abhängigkeitsebene
betrachtet werden. Dies ermöglicht eine direktere und effizientere Nutzung der
zugrunde liegenden Echtzeit-, sowie Speicherressourcen.

\begin{figure}[htb] \centering
    \includegraphics[width=0.8\textwidth]{assets/Micro-ROS_architecture}
    \caption{Micro-ROS Architektur\cite[S. 6]{koubaa2023}}
    % \label{fig:uros_architecture}
\end{figure}

Nach dem Wechsel zu FreeRTOS wird die Echtzeitleistung der Steuerungssoftware
analysiert mit einem besonderen Fokus auf den Overhead, der durch die
Micro-ROS-Schicht verursacht wird. Der Vergleich soll aufzeigen, inwiefern
FreeRTOS durch die Eliminierung dieser zusätzlichen Abhängigkeit eine
effizientere und leichtgewichtige Lösung für kritische Roboteranwendungen
darstellt. Dabei soll der Einsatz einer zyklengenaue Messung des Programmablaufs
ermöglichen, fundierte Aussagen über die Echtzeitfähigkeit beider Plattformen zu
treffen, und den Leistungsgewinn anhand von diesem Beispiel für eine
Steuerungssoftware quantitativ zu belegen.

\subsection{FreeRTOS}

FreeRTOS ist ein Open-Source, leichtgewichtiges \ac{RTOS}, das speziell für
eingebettete Systeme entwickelt wurde. Es zeichnet sich unter anderem durch
deterministisches Verhalten mit Echtzeitgarantie sowie Konfigurierbarkeit der
Heap-Allokation aus. Diese Eigenschaften machen es zu einer geeigneten Wahl für
Robotersteuerungssoftware, insbesondere wenn Echtzeitanforderungen und
effiziente Ressourcennutzung im Vordergrund stehen.

\subsubsection{Konzepte}

FreeRTOS unterscheidet sich von der Bare-Metal-Programmierung dadurch, dass es
eine nützliche Abstraktionsebene für den Nutzer bereitstellt. Diese
Abstraktionen ermöglichen es, komplexere Echtzeitanforderungen zu bewältigen,
ohne dass der Nutzer diese Funktionalitäten selbst implementieren muss.
Beispiele hierfür sind Timer mit konfigurierbarer Genauigkeit (basierend auf den
sogenannten Tick \cite{freertos_rtos_tick, freertos_tick_resolution}),
threadsichere Queues sowie Semaphore und Mutexe \cite{freertos_queues}. Diese
Komponenten bieten fertige Lösungen für häufige Herausforderungen in der
Entwicklung eingebetteter Systeme, sodass der Nutzer solche Werkzeuge nicht mehr
selbst anfertigen muss.

Im Fokus dieser Arbeit stehen Queues und „Direct Task Notifications“, die in der
Robotersteuerungssoftware zum Einsatz kommen, sowie Semaphore und die
sogenannten „Trace Hooks” für die darauffolgende Echtzeitanalyse. Diese
Komponenten werden im Folgenden detailliert erläutert.

\paragraph{Queues}

Queues sind eine der Kernkomponenten von FreeRTOS und dienen der
Interprozesskommunikation zwischen Tasks. Sie ermöglichen den threadsicheren
Austausch von Daten, und können sowohl zur Datenübertragung als auch zur
Synchronisation von Tasks verwendet werden, da dedizierte
(Ressourcen-)\\Synchronisationsmechanismen wie Semaphore und Mutexe sind auf
Queues aufgebaut \cite{freertos_semphr_incl}.

\paragraph{Semaphore}

Wie bereits kurz erwähnt, sind Semaphore und Mutexe Tools, die den Zugriff auf
gemeinsame Ressourcen koordinieren, wobei Semaphore auch zur Synchronisation von
Tasks genutzt werden können. Semaphoren sind einfache Mechanismen ohne
Unterstützung von Prioritätsvererbung, bei der ein Task mit Besitz von einem
Mutex mit einer niedrigeren Priorität künstlich auf die gleiche Priorität des
auf den Mutex wartenden Task angehoben
wird~\cite{wikipedia_priority_inheritance}. Wenn eine Ressource mit einem
Semaphor geschützt ist, kann dies zu Prioritätsinversion führen, bei der ein
niedriger priorisierter Task die Ressource weiter blockiert, die ein höher
priorisierter Task benötigt~\cite{wikipedia_priority_inversion}.

\begin{figure}[htb]
    \centering
    \includegraphics[width=1\textwidth]{assets/prio_inversion}
    \caption{Priority Inversion}
\end{figure}

\paragraph{Mutexe}

Im Gegensatz dazu sind Mutexe („Mutual Exclusion“) Synchronisationsmechanismen
in FreeRTOS, die Prioritätsvererbung implementieren \cite{freertos_mutexes}.
Wenn ein Task auf einen Mutex wartet, der von einem niedriger priorisierten Task
gehalten wird, wird dieser Task temporär auf die Priorität des wartenden Tasks
erhöht~\cite{FreertosForumSemphMtx}, so dass er den Mutex schnell wieder
freigeben kann.

\begin{figure}[htb]
    \centering
    \includegraphics[width=1\textwidth]{assets/prio_inheritance}
    \caption{Priority Inheritance}
\end{figure}

\paragraph{Direct Task Notifications}

Direct Task Notifications sind ein effizienterer und ressourcensparender
Mechanismus zur Task-Synchronisation \cite{freertos_task_notifications_desc}. Im
Gegensatz zu Semaphoren oder den zugrunde liegenden Queues senden sie direkte
Signale an einen Task, ohne zusätzliche Datenstrukturen zu benötigen, indem sie
den internen Zähler eines Tasks verändern \cite{freertos_tasks_c_213}. Mittels
Funktionen wie zum Beispiel \mintinline{c}|ulTaskNotifyGive()| wird dieser Wert
inkrementiert~\cite{freertos_tasks_c_4296}, während Funktionen wie
\mintinline{c}|ulTaskNotifyTake()| ihn wieder
dekrementieren~\cite{freertos_tasks_c_3926}. Dieses Verhalten ist analog zu dem
von Semaphoren.

Das Entblocken eines Tasks soll bis zu 45\% schneller sein und benötigt weniger
RAM als über ein Zwischenobjekt, z.B. ein Semaphor
\cite{freertos_task_notifications_usage}.

\paragraph{Trace Hooks}

„Trace Hooks“ sind spezielle Macros in der FreeRTOS-API, deren Nutzung es
beispielsweise ermöglicht, Ereignisse im System zu verfolgen und zu
protokollieren. Diese Macros müssen vor der Einbindung von
\mintinline{text}|FreeRTOS.h| definiert werden und werden innerhalb von
Interrupts aufgerufen \cite{freertos_rtos_trace_hooks}.

\subsection{Echtzeitanalyse}

Um die Echtzeitanalyse der Steuerungssoftware durchzuführen, ist eine Methode
erforderlich, die jeden Ausführungsabschnitt des Codes flexibel, präzise und
threadsicher messen kann. Da die Software multithreaded ist, muss sichergestellt
werden, dass die Messungen trotz Interrupts und preemptivem Scheduling korrekt
und zyklengetreu durchgeführt werden können.

Basierend auf den oben genannten Herausforderungen bietet die \ac{DWT} eine
geeignete Lösung \cite{ARM_KA001499}. Die DWT ist ein Hardwaremodul in
Prozessoren inklusive ARMv7-M, das speziell für die Analyse von Programmabläufen
entwickelt wurde \cite{ARMv7_ref_man_dwt_profiling}. Ein für diese Arbeit
zentraler Bestandteil der DWT ist der Zyklenzähler \mintinline{c}|DWT_CYCCNT|,
der bei jedem Takt inkrementiert wird, solange sich der Prozessor nicht im
Debug-Zustand befindet \cite{ARMv7_ref_man_dwt_cycle}. Dadurch ermöglicht die
DWT beispielsweise die Erfassung von Echtzeitaspekten mit zyklengenauer
Präzision under normaler Operation \cite{ARMv7_ref_man_dwt}.

\subsubsection{Beispiel: SEGGER SystemView}

Ein Beispiel hierfür ist SEGGER SystemView, ein Echtzeit-Analysewerkzeug, das
den DWT-Zyklenzähler einsetzt, um Live-Code-Profiling auf eingebetteten Systemen
durchzuführen \cite{SEGGER_SystemView}.

% TODO maybe not inline code to bloat the thesis
Das SEGGER SystemView nutzt den DWT, indem die Funktion \linebreak
\mintinline{c}|SEGGER_SYSVIEW_GET_TIMESTAMP()| einfach die hardkodierte
Registeradresse des Zyklenzählers zurückgibt, anstatt die interne Funktion
\mintinline{c}|SEGGER_SYSVIEW_X_GetTimestamp()| aufzurufen
\cite{SystemView_Config, Arm_DWT_Programmers_Model}. Dies erfolgt, sofern das
Macro \mintinline{c}|SEGGER_SYSVIEW_CORE_CM3| definiert ist
\cite{SystemView_Config_79}. Aus dieser Definition wird gezeigt, dass die
Nutzung des DWT für Cortex-M3, M4 sowie M7 Prozessoren aktiviert wird. Daraus
könnte sich eventuell auch schlussfolgern lassen, dass der DWT nur auf diesen
Prozessoren verfügbar ist.

Aufgrund dieser Eigenschaften der DWT wird die Implementierung für die
Echtzeitanalyse auf dieser Komponente aufbauen.
