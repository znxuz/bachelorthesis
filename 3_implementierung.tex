\section{Implementierung zur Echtzeitanalyse}

Nachdem die Steuerungssoftware auf zwei verschiedenen Architekturen, nämlich
FreeRTOS und Micro-ROS, aufgebaut wurde, kann nun eine konkrete Implementierung
der Echtzeitanalyse basierend auf FreeRTOS erfolgen, um die Portabilität auf
Micro-ROS zu ermöglichen. Ziel der Analyse ist es, Informationen darüber zu
gewinnen, wie lange eine bestimmte Task oder eine bestimmte zeitkritische
Funktion benötigt. Die daraus resultierenden Daten müssen mit einer angemessenen
Genauigkeit erfasst werden, um sicherzustellen, dass die Echtzeitaspekte korrekt
widergespiegelt werden.

Aufgrund von Hardwarebeschränkungen sowie Einfachheit wurde UART als
Kommunikationsschnittstelle zur Übertragung der Echtzeitdaten vom
Mikrocontroller zum Host gewählt. Mit einer theoretischen Übertragungsrate von
bis zu 12,5 Mbit/s bietet UART ausreichende Bandbreite~\cite[S.
2]{stm32_datasheet}, um die Profiling-Daten zu übertragen, ohne Überlastung zu
verursachen.

Daraus ergibt sich als Erstes die Notwendigkeit, eine threadsichere \ac{MPSC}
Queue, oder besser gesagt eine Multi Producer Senke, zu implementieren, welche
die Profiling-Daten kontinuierlich in Echtzeit konsumiert und sie über UART
ausgibt. Die FreeRTOS Stream- oder Messagebuffer sind für den Fall mit mehreren
Producers nicht geeignet~\cite{FreeRTOSStreamBuffer}.

\subsection{Threadsichere Senke}

Da FreeRTOS und dementsprechend auch Micro-ROS multithreaded sind und zur
Echtzeitanalyse Daten von beliebiger Stelle beim Programmlauf durch IO
übertragen werden, muss dabei die Thread-Sicherheit gewährleistet werden, damit
die zu übertragenden Daten nicht durch Race Conditions neu geordnet,
überschrieben oder zu unbrauchbaren Daten werden.

Die grundlegende Idee besteht darin, dass Daten aus mehreren Threads in die
Senke gepusht, oder besser gesagt in einen internen Puffer gespeichert werden
und dann darauf warten, von einem einzelnen Verbraucher verarbeitet zu werden.
Da der Speicher begrenzt ist, muss die Senke in der Lage sein zu erkennen, wann
sie das weitere Schreiben von Daten in den Puffer blockieren muss, um zu
verhindern, dass zuvor geschriebene, aber noch nicht verarbeitete Daten
überschrieben werden.

Inspiriert von einem C++-Konferenzvortrag über eine \ac{MPMC}-Warteschlange aus
dem Jahr 2024~\cite{CppCon2024LockFreeQueue}, in dem jede Position des
Datenpuffers eine eindeutige Sequenznummer besitzt, diese bei der Entnahme der
Daten atomar um die Gesamtlänge des Datenpuffers $N$ erhöht, wodurch angezeigt
wird, dass die Daten an dieser Position bereits in der Iteration $N$ verarbeitet
wurden und somit in der nächsten Iteration $N + 1$ vom Schreiber überschrieben
werden können, was durch den Vergleich mit der globalen Schreibsequenznummer
ermöglicht wird, die ebenfalls nach jedem Schreibvorgang atomar erhöht wird.

Für den Fall einer Senke mit aber nur einem einzigen Verbraucher reicht es aus,
den Zustand als \mintinline{cpp}|bool| zu speichern, der angibt, ob die Daten an
einer bestimmten Position noch verarbeitet werden müssen oder bereits
überschrieben werden können.

Durch die Verwendung von DMA gepaart mit einem Interrupt-Callback ausgelöst bei
jedem Abschluss einer DMA-Übertragung wird die typische IO-gebundene Zeit
eliminiert, da in diesem Fall das Schreiben von Daten in das IO einfach zum
Schreiben in einen In-Memory-Puffer wird, während die eigentlichen
IO-Operationen auf den DMA-Controller verlagert werden. Wenn das tatsächliche IO
die Daten schnell genug überträgt, um mit den eingehenden Daten Schritt zu
halten, entsteht keine Situation, in der eine Task darauf warten muss, dass die
Senke Speicherplatz freigibt, um den Schreibvorgang weiter durchzuführen.

\subsubsection{Schreibvorgang in die Senke}

Um das Schreiben in die Senke threadsicher zu machen, wird ein Mutex verwendet.
Dies stellt sicher, dass ein Thread, der ein Mutex hält, niemals vom Scheduler
ausgeschlossen wird (\ref{sec:mutex}). Bei jedem zu schreibenden Byte in den
Puffer wird überprüft, ob die Daten an der aktuellen Position bereits
verarbeitet wurden. Falls dies nicht der Fall ist, verzögert sich der Thread
durch präemptives Warten und gibt die Kontrolle an den Scheduler zurück, um
Polling to vermeiden. Nachdem das Byte in den Puffer geschrieben wurde, wird der
globale Schreibindex samt dem Zustand dieser Position aktualisiert. Erst nachdem
alle Bytes in den Puffer geschrieben wurden, wird das Mutex freigegeben
\cite{FreeRTOSForumPrintf}.

\begin{code}
\begin{minted}{cpp}
void tsink_write(const char* ptr, size_t len) {
  xSemaphoreTake(write_mtx, portMAX_DELAY);
  for (size_t i = 0; i < len; ++i) {
    while (consumable[write_idx]) vTaskDelay(1);

    sink[write_idx] = ptr[i];
    taskENTER_CRITICAL();
    consumable[write_idx] = true;
    write_idx = (write_idx + 1) % SINK_SIZE;
    taskEXIT_CRITICAL();
  }
  xSemaphoreGive(write_mtx);
}
\end{minted}
    \captionof{listing}{Schreib-API von der Senke}
\end{code}

\subsubsection{Lesevorgang aus der Senke}

Eine kleine, statisch allokierte FreeRTOS-Task wird erstellt, um kontinuierlich
zu versuchen, verfügbare Daten aus der Senke zu entnehmen und verarbeiten.
Mithilfe des Lese- und Schreibzeigers kann die Größe der verarbeitbaren Daten
berechnet werden, und zusammen mit dem Zeiger auf die Daten werden diese in die
vom Benutzer bereitgestellte Funktion zur Verarbeitung von Daten übergeben.

\begin{code}
\begin{minted}{cpp}
using tsink_consume_f = void (*)(const uint8_t* buf, size_t size);
tsink_consume_f consume;

void consume_and_wait(size_t pos, size_t size) {
  auto update_for_writer = [](size_t pos, size_t size) static {
    for (size_t i = 0; i < size; ++i) consumable[pos + i] = false;
  };

  consume(sink + pos, size);
  ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
  update_for_writer(pos, size);
}

void task_impl(void*) {
  size_t pos = 0;
  while (true) {
    auto end = write_idx;
    if (pos == end && !consumable[pos]) {
      vTaskDelay(1);
      continue;
    }

    auto size = (pos < end ? end : SINK_SIZE) - pos;
    consume_and_wait(pos, size);
    if (pos >= end && end) consume_and_wait(0, end);

    pos = end;
  }
}
\end{minted}
    \captionof{listing}{Implementierung der Task zur Datenverarbeitung}
    \label{code:consume}
\end{code}

Nachdem die Daten mittels \mintinline{cpp}|consume()| verarbeitet wurden,
blockiert sich die Task selbst und gibt wieder die Kontrolle über
\mintinline{cpp}|ulTaskNotifyTake()| an den Scheduler zurück, um sich mit den
tatsächlichen IO-Operationen zu synchronisieren. Diese Vorgehensweise ist
besonders effizient, wenn \mintinline{cpp}|consume()| intern DMA nutzt: Die
DMA-Instruktion zur Datenübertragung signalisiert dabei lediglich der Hardware
den Transfervorgang und kehrt sofort zurück \cite{HAL_UART_Transmit_DMA}.
Konkret werden die Daten einfach zur Verarbeitung für den DMA eingereiht,
während der Programmfluss unmittelbar fortgesetzt wird.

Erst nachdem das Signal durch den Aufruf von
\mintinline{cpp}|tsink_consume_complete()| empfangen wurde, beispielsweise von
einer \ac{ISR}, die durch den DMA nach Abschluss der Übertragung ausgelöst wird,
wird die Task wieder entblockt und das Zustandsarray für die Positionen, von
denen Daten gelesen wurden, aktualisiert, so dass diese sicher mit neuen Daten
überschrieben werden können.

\begin{code}
\begin{minted}{cpp}
enum struct TSINK_CALL_FROM { ISR, NON_ISR };

template <TSINK_CALL_FROM callsite>
void tsink_consume_complete() {
  if constexpr (callsite == TSINK_CALL_FROM::ISR) {
    static BaseType_t xHigherPriorityTaskWoken;
    vTaskNotifyGiveFromISR(task_hdl, &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
  } else {
    xTaskNotifyGive(task_hdl);
  }
}
\end{minted}
    \captionof{listing}{Callback zur Task-Notification}
\end{code}

Auf der ARM-Architektur sind alle ausgerichteten Byte-, Halbwort- und
Wortzugriffe standardmäßig atomar~\cite[S. A3-79]{ARM_DDI0403_EE}. Daher ist der
direkte Zugriff auf Variablen wie \mintinline{cpp}|size_t write_idx| oder
Elemente des Arrays \mintinline{cpp}|bool consumable[]| standardmäßig atomar und
threadsicher, ohne dass es zu Schreib-Lese-Konflikten kommt.

\subsubsection{Nutzung der Senke mit DMA}

Um diese Senke mit DMA und aktiviertem Daten-Cache zu verwenden, muss zunächst
eine benutzerdefinierte Interrupt-Callback
\mintinline{cpp}|HAL_UART_TxCpltCallback()| definiert werden, die bei Abschluss
jedes DMA-Transfers ausgelöst wird. Anschließend ist die
Initialisierungsfunktion der Senke aufzurufen, die einen Funktionszeiger vom Typ
\mintinline{cpp}|tsink_consume_f| zur cache-kohärenten Verarbeitung von
Daten~(\ref{code:cache_clean}) sowie eine Priorität für die FreeRTOS-Task als
Argumente entgegennehmen.

\begin{code}
\begin{minted}{cpp}
void HAL_UART_TxCpltCallback(UART_HandleTypeDef* huart) {
  if (huart->Instance != huart3.Instance) return;
  tsink_consume_complete<TSINK_CALL_FROM::ISR>();
}

void main() {
  auto tsink_consume_dma = [](const uint8_t* buf, size_t size) static {
    auto flush_cache_aligned = [](uintptr_t addr, size_t size) static {
      constexpr auto align_addr = [](uintptr_t addr) { return addr & ~0x1F; };
      constexpr auto align_size = [](uintptr_t addr, size_t size) {
        return size + ((addr) & 0x1F);
      };

      SCB_CleanDCache_by_Addr(reinterpret_cast<uint32_t*>(align_addr(addr)),
                              align_size(addr, size));
    };

    flush_cache_aligned(reinterpret_cast<uintptr_t>(buf), size);
    HAL_UART_Transmit_DMA(&huart3, buf, size);
  };

  tsink_init(tsink_consume_dma, osPriorityAboveNormal);
}
\end{minted}
    \captionof{listing}{Initialisierung der Senke mit DMA}
\end{code}

\subsubsection{Nutzung der Senke mit blockierender IO}

Ähnlich wie bei der Initialisierung über DMA, entfällt hier aber der
Interrupt-Callback, und die Funktion zur Datenverarbeitung wird durch die
Verwendung der blockierenden API vereinfacht. Dies ist möglich, da ohne DMA
keine manuelle Sicherstellung der Cache-Kohärenz notwendig ist.

\begin{code}
\begin{minted}{cpp}
int main() {
  auto tsink_consume = [](const uint8_t* buf, size_t size) static {
    HAL_UART_Transmit(&huart3, buf, size, HAL_MAX_DELAY);
    tsink_consume_complete<TSINK_CALL_FROM::NON_ISR>();
  };

  tsink_init(tsink_consume_dma, osPriorityAboveNormal);
}
\end{minted}
    \captionof{listing}{Initialisierung der Senke mit blockierender IO}
\end{code}

\subsubsection{Benchmark}

Ein Benchmark für die Senke wurde entwickelt, um deren Leistung unter paralleler
Last zu testen. Der Benchmark lässt eine Anzahl von
\mintinline{text}|BENCHMARK_N = 4| Threads gleichzeitig laufen, die jeweils eine
Anzahl von \mintinline{cpp}|iteration = 5000| Nachrichten mit ca. 60 Charaktern
hintereinander über die Senke ausgeben.

Nach Abschluss des Benchmarks werden die gemessenen Zeiten und die
Laufzeitstatistiken der jeweiligen Task ausgegeben.

\begin{minipage}[t]{0.5\textwidth}
    \begin{code}
        \begin{minted}[linenos=false]{cpp}
time in ms: 4174
time in ms: 5995
time in ms: 6017
time in ms: 6102
time elapsed: 6102
===================================
Task            Time            %
IDLE            43211           71%
benchmark       4165            6%
benchmark       4172            6%
benchmark       4173            6%
benchmark       4090            6%
tsink           632             1%
print_bench     1               <1%
Tmr Svc         0               <1%
    \end{minted}
        \captionof{listing}{Benchmark DMA}
    \end{code}
\end{minipage}
\hfill
\begin{minipage}[t]{0.5\textwidth}
    \begin{code}
        \begin{minted}[linenos=false]{cpp}
time in ms: 7524
time in ms: 7530
time in ms: 7692
time in ms: 7806
time elapsed: 7805
===================================
Task            Time            %
IDLE            0               <1%
benchmark       4133            5%
benchmark       4153            5%
benchmark       4150            5%
benchmark       4155            5%
tsink           60752           78%
print_bench     0               <1%
Tmr Svc         0               <1%
    \end{minted}
        \captionof{listing}{Benchmark mit blockierender IO}
    \end{code}
\end{minipage}

Die Ausgabe enthält zwei verschiedene Zeitmessungen für den Benchmark. Die erste
ist die Zeit, die vom Start des jeweiligen Threads bis zum Ende vergangen ist
sowie die Gesamtdauer vom Beginn des gesamten Benchmark-Prozesses bis zu dessen
Abschluss, was praktisch auch der Zeit der letzten Benchmarktask entspricht.

Die zweite Messung bezieht sich auf die FreeRTOS-Laufzeitstatistiken, die durch
\linebreak \mintinline{cpp}|vTaskGetRunTimeStats()| formattiert ausgegeben
werden. Diese liefern die absolute kumulative Zeit für jede Task, die im Zustand
„Running” verbracht hat, sowie deren prozentualen Anteil an der Gesamtlaufzeit
\cite{freertos_runtime_stats}.

Der Benchmark zeigt, dass asynchrone Übertragung per DMA die Gesamtlaufzeit des
Benchmark-Prozesses im Vergleich zur IO-gebundenen Variante um etwa $20\,\%$
verringerte, während gleichzeitig die IO-gebundene Zeit freigegeben wurde,
sodass sie von anderen Aufgaben genutzt werden kann.

Ebenso kann abgeleitet werden, dass durch die Verwendung von DMA die
Datenübertragungsrate nahezu das vorkonfigurierte Maximum der Baudrate von
$2.000.000\text{ bps}$ erreicht wurde. Insgesamt wurden $1.208.894$ Bytes
übertragen, wobei ein UART-Byte-Frame hierbei eine standardmäßige Wortlänge von
8 Bit hat, inklusive je 1 Start- und 1 Stopp-Bit, ohne Paritätsbit.

\begin{align*}
    1.208.894\text{\,B} \times 10\text{\,b per Frame} =
    12.088.940 \text{\,b} = \text{Gesamte Bits}
\end{align*}

Teilt man dies durch die gesamte Übertragungszeit, ergibt sich die effektive
Bitrate sowie der prozentuale Anteil im Vergleich zur maximalen Baudrate:

\begin{align*}
    \text{Bitrate bei DMA} =
    \frac{12.088.940\text{\,b}}{6,102\text{\,s}} \approx
    1.981.143,89 \text{\,bps} \\
    \quad \Rightarrow 99,06\,\%\text{ des Maximums} \\
    \\
    \text{Bitrate bei blockierender IO} =
    \frac{12.088.940\text{\,b}}{7,805\text{\,s}} \approx
    1.548.871,24 \text{\,bps} \\
    \quad \Rightarrow 77,44\,\% \text{ des Maximums}
\end{align*}

\subsection{Implementierung der Messung}

Nachdem die threadsichere Datenausgabe implementiert wurde, kann nun die Frage
geklärt werden, wie die Dauer eines beliebigen Funktionsaufrufs oder einer Task
von der Zuweisung durch den Scheduler bis zum Abschluss gemessen werden kann.

\subsubsection{Aktivierung der DWT}

Wie im vorherigen Abschnitt erläutert \ref{sec:dwt}, stellt die DWT einen
geeigneten Ansatz zur Generierung von Echtzeitdaten in Form von Zyklenzahl dar.
Sie ist standardmäßig auf Cortex-M7-Prozessoren verfügbar und kann durch die
folgenden Konfigurationsschritte aktiviert werden:

\begin{code}
\begin{minted}{cpp}
void enable_dwt() {
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  DWT->LAR = 0xC5ACCE55;  // software unlock
  DWT->CYCCNT = 1;
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
}
\end{minted}
    \captionof{listing}{Aktivierung der DWT \cite{StackOverflow_DWT_Activation}}
\end{code}

Danach kann die aktuelle Zyklenzahl direkt über \mintinline{cpp}|DWT->CYCCNT|
ausgelesen werden.

\subsection{Aufzeichnung von Task-Informationen}

Drei wesentliche Informationen werden bei der Aufzeichnung von
Task-Informationen erfasst: der Identifikator der zugehörigen Task oder
Funktion, der aktuelle Zyklenzahl und ein Marker, der angibt, ob der Zeitstempel
den Beginn oder das Ende einer Taskdauer markiert. Diese Daten werden in einem
Strukturtyp gespeichert.

\begin{code}
\begin{minted}{cpp}
struct TaskRecord {
  const char* name;
  uint32_t cycle;
  bool is_begin;
} __attribute__((packed));
\end{minted}
    \captionof{listing}{Strukturtyp zur Task-Aufzeichnung}
\end{code}

Da das Schreiben in die Senke per se nicht „lock-free” ist, kann es nicht direkt
in einer ISR zur Generierung von solchen task-Datensätzen aufgerufen werden.
Stattdessen müssen sie erst in einen temporären Puffer reingeschrieben werden.

\begin{code}
\begin{minted}{cpp}
inline std::array<TaskRecord, 512> records{};
volatile inline size_t record_idx = 0;
volatile inline bool task_profiling_enabled = 0;
\end{minted}
    \captionof{listing}{Globaler Temporärbuffer mit dessen Schreibindex und
    Aktivierungsflag}
\end{code}

Eine Funktion zur Aufzeichnung von Task-Datensätzen ist wie folgt definiert:

\begin{code}
\begin{minted}{cpp}
template <bool from_isr>
inline void record(const char* name, bool is_begin) {
  struct disable_isr_guard {
    disable_isr_guard() { taskENTER_CRITICAL(); }
    ~disable_isr_guard() { taskEXIT_CRITICAL(); }
  };

  if constexpr (!from_isr) volatile auto _ = disable_isr_guard();

  records[record_idx] = {name, DWT->CYCCNT, is_begin};
  record_idx = (record_idx + 1) % records.size();
}
\end{minted}
    \captionof{listing}{Funktionsdefinition zur Aufzeichnung von
    Task-Datensätzen}
\end{code}

Innerhalb der Funktion ist die Definition eines Typs \mintinline{cpp}|struct
disable_isr_guard| zu finden, welcher dafür sorgt, dass diese Funktion, wenn
auch von einem nicht-ISR-Kontext aufgerufen wird, die Aufzeichnung
beziehungsweise den gesamten Funktionsblock als ein kritischer Abschnitt
ausführt.

Das Konzept von \ac{RAII} wird hierbei angewendet, um beim Konstruieren eines
Objekts von diesem Typ automatisch die Funktion
\mintinline{cpp}|taskENTER_CRITICAL()| sowie bei dessen Dekonstruktion – beim
Verlassen der Funktion \mintinline{cpp}|record()| –
\mintinline{cpp}|taskEXIT_CRITICAL()| aufzurufen und dadurch einen kritischen
Abschnitt bilden. Laut des ISO-C++-Standards wird der Aufruf von Destruktoren
mit „Side Effects” nicht durch Optimierung eliminiert, und erfolgt garantiert am
Ende eines Funktionsblocks~\cite[§ 6.7.5.4 Abs. 3]{iso_iec_14882_2020}, und zwar
in der umgekehrten Reihenfolge, wie die Objekte kreiert worden sind
\cite{isocpp_dtor_order}.

Mit einem kritischen Abschnitt kann somit sichergestellt werden, dass zwischen
der Lesezugriff auf den Schreibindex \mintinline{cpp}|record_idx| und dessen
Inkrementierung nicht durch Kontextwelchsel unterbrochen wird, so dass die
geschriebene Daten nicht unmittelbar vor der Inkrementierung des Schreibindexes
von anderen Threads überschrieben werden.

Mittels einer booleschen Variable als Template-Argument, gepaart mit
\mintinline{cpp}|if constexpr|, kann zur Übersetzungszeit festgelegt werden, ob
das Objekt erzeugt oder weggelassen werden soll. Konkret werden dabei zwei
unterschiedliche Versionen dieser Funktion durch den Compiler generiert, wodurch
das Branching zur Laufzeit vollständig eliminiert wird
\cite{cppreference_constexpr_if}. Je nachdem, ob der Boolean falsch oder wahr
ist, wird die entsprechende Version mit oder ohne die Erzeugung des Objekts für
den kritischen Abschnitt aufgerufen.

\subsubsection{Nutzung von Trace Hooks zur Task-Aufzeichnung}

FreeRTOS bietet eine Vielzahl von Makros, die beim Scheduling als ISR-Callbacks
aufgerufen werden können (\ref{sec:trace_hooks}). Das Makro
\mintinline{cpp}|traceTASK_SWITCHED_IN()| wird aufgerufen, nachdem eine Task zum
Ausführen ausgewählt wurde. \mintinline{cpp}|traceTASK_SWITCHED_OUT()| wird
aufgerufen, unmittelbar bevor eine neue Task ausgewählt wird. An diesen
Zeitpunkten enthält der interne Task-Control-Block von FreeRTOS
\mintinline{cpp}|pxCurrentTCB| das Handle der Task, die gerade den Zustand
"Running" betritt oder verlässt, wodurch der Nutzer die Chance hat, direkt auf
die Metadaten der aktuellen Task zuzugreifen. (\cite{freertos_rtos_trace_hooks})

Da die Definitionen solcher Makros immer vor der Einbindung der
\mintinline{text}|FreeRTOS.h| erfolgen müssen, können sie einfachheitshalber
am Ende der \mintinline{text}|FreeRTOSConfig.h| definiert werden.

\begin{code}
\begin{minted}{cpp}
void task_switched_in_isr(const char* name); // forward declaration
#define traceTASK_SWITCHED_IN() task_switched_in_isr(pxCurrentTCB->pcTaskName)
void task_switched_out_isr(const char* name); // forward declaration
#define traceTASK_SWITCHED_OUT() task_switched_out_isr(pxCurrentTCB->pcTaskName)
\end{minted}
    \captionof{listing}{Konkrete Definition der Trace Hook Makros}
\end{code}

Hierbei werden die Makros jeweils als ein Aufruf einer Funktion mit dem Namen
der aktuellen Task als Parameter definiert. Das Feld
\mintinline{cpp}|uxTaskNumber| vom Typ \mintinline{cpp}|unsigned long| aus der
\mintinline{cpp}|pxCurrentTCB|-Struktur, das eigentlich speziell zum
Identifizieren für Drittanbieter-Software konzipiert
ist~\cite{freertos_task_c_410}, kann in dem Falle auch als möglicherweise der
leichtgewichtigste Identifikator genutzt werden. Da das Ausgeben des
menschenlesbaren Namens kein Bottleneck verursacht und man in der
Nachbearbeitung nicht jede generierte Task-Aufzeichnung manuell mit der
zugehörigen Task abgleichen muss, wird einfachheitshalber auf den Namen
entschieden.
